var fs = require("fs");
var path = require("path");
var logger = console;
var xmlreader = require("xmlreader");
var iconv = require("iconv-lite");
var async = require("async");
var ns = {"A": 1,"B": 2,"C": 3,"D": 4,"E": 5,"F": 6,"G": 7,"H": 8,"I": 9,"J": 10,"K": 11,"L": 12,"M": 13,"N": 14,"O": 15,"P": 16,"Q": 17,"R": 18,"S": 19,"T": 20,"U": 21,"V": 22,"W": 23,"X": 24,"Y": 25,"Z": 26};
(function(require, exports, module){
	module.exports = {
		read : function(filename, rcallback) {
			/*if(filename.indexOf(".xlsx") == -1){
				filename += ".xlsx";
			}*/
			var xlsx = this.readXlsx(filename);
			if(!xlsx){
				rcallback("not find "+filename);return;
			}
			var self = this;
			async.parallel([
				function(callback) {
					self.readWorkBook(xlsx, callback);
				},
				function(callback) {
					self.readSharedStrings(xlsx, callback);
				}
			], function(err, res) {
				if(err){return rcallback(err);}
				self.forEachWork(xlsx,res,rcallback);
			});
		},
		readXlsx: function(filename) {
			var zip ;
			try {
				var data = fs.readFileSync(filename,'binary').toString();   
				zip = new require("node-zip")(data,{base64:false});			
			}catch(e){
				//
			}
		    return zip;
		},
		readWorkBook: function(xlsx, callback) {
			xmlreader.read(xlsx.files['xl/workbook.xml'].data, function(err, res) {
				if(err){callback(err);return;}
				if(res.workbook.sheets.sheet.array){
					callback(null, res.workbook.sheets.sheet.array);
				}else{
					callback(null, [res.workbook.sheets.sheet]);
				}
				
			});
		},
		readSharedStrings: function(xlsx, callback) {
			xmlreader.read(xlsx.files['xl/sharedStrings.xml'].data, function(err , res) {
				if(err){callback(err);return;}
				if(res.sst.si.array){
					callback(null, res.sst.si.array);
				}else{
					callback(null, [res.sst.si]);
				}
				
			});
		},
		forEachWork: function(xlsx, res, callback) {
			var data = {};
			var funcs = this.doSheets(xlsx, res, data);
			async.parallel(funcs, function(err, res) {
				if(err){callback(err);return;}
				callback(null, data);
			});
		},
		doSheets: function(xlsx, res, data) {
			var funcs = [];
			data.sheets = [];
			var self = this;
			function doXml(xml) {
				xmlreader.read(xlsx.files['xl/worksheets/sheet'+xml.attributes()['r:id'].substring(3)+".xml"].data, function(err, r){
					data.sheets[parseInt(xml.attributes()['r:id'].substring(3))-1] = iconv.decode(xml.attributes().name);
				 	data[ iconv.decode(xml.attributes().name)] = self.doRows(r.worksheet.sheetData.row, res);
				});
			}
			
			res[0].forEach(doXml);
			
			
			return funcs;
		},
		doRows: function(rowsData, res) {
			if(rowsData) {
				//可能没有array 
				var rows = [];
				if(rowsData.array){
					for(var i = 0; i< rowsData.array.length;i++) {
						var cs = rowsData.array[i].c;
						rows[rowsData.array[i].attributes().r - 1] = this.doRow(cs, res);
					}
				}else{
					//只有一个row的情况  new情况
					var cs = rowsData;
					rows[rowsData.attributes().r - 1] = this.doRow(cs.c, res);
				}
				return rows;
			}
		},
		doRow: function(rowData, res) {
			var self = this;
			if(rowData){
				var row = [];
				var run  = function(c) {
					var ireg = /([A-Za-z]+)/;
					var index = self.toNum(c.attributes().r.match(ireg)[0]);
					row[index] = self.doOne(c, res[1]);
				}
				if(rowData.array) {
					for(var i = 0;i<rowData.array.length;i++) {
						var c = rowData.array[i];
						//run(rowData.array[i]);
						var ireg = /([A-Za-z]+)/;
						var index = self.toNum(c.attributes().r.match(ireg)[0]);
						row[index] = self.doOne(c, res[1]);
					}
				}else{
					//run(rowData);
					var c = rowData;
					var ireg = /([A-Za-z]+)/;
					var index = self.toNum(c.attributes().r.match(ireg)[0]);
					row[index] = self.doOne(c, res[1]);
				}
				return row;
			}
		},
		toNum : function(letter) {
		 	if (!letter) return 0; 
		    var  n = 0;
		    for (var i = letter.length - 1, j = 1; i >= 0; i--, j *= 26){
		        var c = letter[i];
		        if (c < 'A' || c > 'Z') return 0;
		        n += ns[c] * j;
		    }
		    return n-1;
		},
		doOne: function(data, sharedStrings) {
			var self = this;
			if(data.attributes().t == "s") {
				return self.getString(data, sharedStrings);
			}else{
				if(data.v) {
					if(!data.v.text){
						return "";
					}else{
						if(parseFloat(data.v.text())) {
							return parseFloat(data.v.text());
						}else{
							return iconv.decode(data.v.text());
						}
					}
					
				}else{
					return "";
				}
			}
		},
		getString: function(data, sharedStrings) {
			if(data && data.v && data.v.text && data.attributes().t != null ){
				var strData = sharedStrings[data.v.text()];
				if(strData.t) {
					if(strData.t.text) {
						return iconv.decode(strData.t.text(),"UTF8");
					}else{
						return "";
					}
					
				}else if(strData.r){
					var str = "";
					if(strData.r.array) {
						for(var  i = 0,l = strData.r.array.length; i<l ;i++) {
		                    if(strData.r.array[i].t ){
		                        if( strData.r.array[i].t.text){
		                            str += iconv.decode(strData.r.array[i].t.text());
		                        }else{
		                            //throw new Error("bug:"+JSON.stringify(strData.r.array[i]));
									str += "";
		                        }
		                        
		                    }
		                }
					}else{
						str = iconv.decode(strData.r.t.text());
					}
					return str;
				}
			}
		}
	}
})(require, exports, module);